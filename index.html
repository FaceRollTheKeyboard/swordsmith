<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>swordsmith</title>
    <script src="three.js"></script>
    <style>
        body{
            padding:0px;
            margin: 0px;
            box-sizing: border-box;
        }
        #world {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(#e4e0ba, #f7d9aa);
        }
    </style>
</head>
<body onload="init()">
<div id="world"></div>

<script src="./object/scene.js"></script>
<script src="./object/ground.js"></script>
<script src="./object/player.js"></script>
<script src="./object/sword.js"></script>
<script src="./object/target.js"></script>
<script>
    //定义色彩
    var Colors = {
        red:0xf25346,
        white:0xd8d0d1,
        brown:0x59332e,
        pink:0xF5986E,
        brownDark:0x23190f,
        blue:0x68c3c0
    };

    function init() {
        // 创建场景，相机和渲染器
        createScene();
        // 添加光源
        createLights();
        // 添加对象
        createPlayer();
        createGround();
        createTarget()

        renderer.render(scene, camera);

        //添加监听器
        document.addEventListener('mousemove', handleMouseMove, false);
        document.addEventListener('click',handleMouseClick,false)

        // 调用循环函数，在每帧更新对象的位置和渲染场景
        loop();
    }

    function loop(){
//        sea.mesh.rotation.z += .005;
//        sky.mesh.rotation.z += .01;
//
//        // 更新每帧的飞机
//        updatePlane();
//        airplane.pilot.updateHairs();
//
        camera.position.x=player.mesh.position.x
        camera.position.z=player.mesh.position.z+200
        camera.lookAt({
            x:player.mesh.position.x,
            y:player.mesh.position.y,
            z:player.mesh.position.z+20
        })
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
    }
//
//    function updatePlane(){
//
//        // 让我们在x轴上-100至100之间和y轴25至175之间移动飞机
//        // 根据鼠标的位置在-1与1之间的范围，我们使用的 normalize 函数实现（如下）
//
//        var targetX = normalize(mousePos.x, -1, 1, -100, 100);
//        var targetY = normalize(mousePos.y, -1, 1, 25, 175);
//
//        // 更新飞机的位置
//        airplane.mesh.position.y = targetY;
//        airplane.mesh.position.x = targetX;
//        airplane.propeller.rotation.x += 0.3;
//    }

    function normalize(v,vmin,vmax,tmin, tmax){

        var nv = Math.max(Math.min(v,vmax), vmin);
        var dv = vmax-vmin;
        var pc = (nv-vmin)/dv;
        var dt = tmax-tmin;
        var tv = tmin + (pc*dt);
        return tv;
    }

    var mousePos={x:0, y:0};

    // mousemove 事件处理函数

    function handleMouseMove(e) {

        //获取目标位置
        console.log(e)
        //将鼠标点击位置的屏幕坐标转成threejs中的标准坐标
        mouse.x = (e.clientX/window.innerWidth)*2 -1;
        mouse.y = -(e.clientY/window.innerHeight)*2 + 1;
        //从相机发射一条射线，经过鼠标点击位置
        raycaster.setFromCamera(mouse,camera);
        //计算射线相机到的对象，可能有多个对象，因此返回的是一个数组，按离相机远近排列
        var intersects = raycaster.intersectObjects(scene.children);

        ForEach(intersects,function (el, i) {
            if(el.object.name='ground'){
                console.log(el)
                target.mesh.position.set(el.point.x,el.point.y,el.point.z)
            }
        })

    }

    var raycaster=new THREE.Raycaster();
    var mouse=new THREE.Vector2();
    function handleMouseClick(e) {

    }

    //遍历数组和对象
    /*
     * for each 语句，
     * 实现for 和for(var i in y)的功能
     * 调用时
     ForEach(obj,function(i){
     })
     * */
    function ForEach(obj, func) {
        if (typeof obj == "object") {
            if (obj.length == undefined) {
                for (var x in obj) {
                    //传入（每一项，每一项的序列号）
                    func(obj[x], x);
                }
            } else {
                for (var i = 0; i < obj.length; i++) {
                    //传入（每一项，每一项的序列号）
                    func(obj[i], i);
                }
            }
        } else {
            console.log('类型错误:' + JSON.stringify(obj))
        }
    }

</script>

</body>
</html>